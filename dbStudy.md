# DATA BASE STUDY

----------------------------------------------------------------

# (회복)recovery

* 데이타베이스 응용 시스템에 장애가 발생했을 때, DB를 장애 발생 이전의 일괄된 상태 (consistent state)로 복원시키는 것.
  * 일관된 상태(consistent state)
    * 데이터베이스에 **오류가 없는 상태**,
    * 데이터베이스 내용에 모순이 없는 상태를 말한다.

* 장애(Failure)
  * 시스템이 정해진 명세대로 작동하지 않는 상태
  * 원인
    * 디스크 붕괴, 하드웨어 결함, 소프트웨어의 논리오류, 사람의 실수 등.

## 장애의 유형

1. 트랜잭션 장애
   * 트랜잭션이 정상적으로 실행을 지속할 수 없는 상태
   * 트랜잭션 내의 1. 논리적 오류, 2. 입력 데이터 불량, 3. 시스템 자원 과다 사용 등이 원인이다.

2. 시스템 장애
   * 하드웨어 오동작으로 주기억장치의 정보 손실, 교착 상태 등이 발생

3. 미디어 장애
   * 디스크 헤드 고장 또는 저장미디어 붕괴 등으로 데이터베이스 손상 발생

## 회복 관리자(Recovery manager): subsystem of DBMS

* DBMS 전체 코드의 상당 부분을 차지
* 신뢰성 있는 회복을 책임짐
  * 회복(recovery) 능력은 DB시스템 신뢰성에 주요 Issue!!

1. 회복관리자의 기능
   * 장애 탐지
   * 데이터베이스 복원

2. 회복 작업의 특징
   * 최단시간 내 손상된 부분만을 포함하는 최소의 범위
   * 트랜잭션 기반 회복
   * 회복자료의 보장
   * 시스템 레벨의 자동조치

## 회복의 기본원리: 중복(redundancy)

> 1. 덤프(dump)
>
> * DB를 다른 저장장치에 복제(archive)

> 2. 로그(log, journal)
>
> * DB에 수행한 갱신연산을 기록
> * 갱신 연산의 targer 데이터 아이템의 옛 값과 새 값(old/new value)을 별도의 파일에 기록

## 회복을 위한 조치

1. REDO: 재실행
   * 완료된 데이터베이스 내용이 손실되었을 경우
   * 가장 최근 복제본(dump) 적재 + 로그(복제본 이후 변경된 기록)를 이용
      * -> 손실된 데이타베이스 내용 복구

2. UNDO: 실행 취소
   * 현재 실행 중인 트랜잭션이 정상적으로 완료 불가능한 경우
   * 로그를 이용, 현재 트랜잭션이 수행한 모든 변경들을 취소
      * -> 트랜잭션 실행전의 데이터베이스 상태로 **복원**

# 데이터베이스 저장연산

## 저장장치 분류(장애에 대한 탄력성 기준)

1. 소멸 저장장치(volatile storage)
   * 메인 메모리
   * 시스템의 붕괴와 함께 저장된 데이터 상실

2. 비소멸성 저장장치(nonvolatile storage)
   * 디스크나 테이프
   * 시스템 붕괴 시에도 보통 저장된 데이터는 손실되지 않는다.
   * 저장장치 자체의 고장으로 손실이 가능하다.

3. 안정 저장장치(stable storae)
   * 데이터의 손실 발생을 최대한 억제한 비소멸 저장장치
   * RAID Level 1(5, 6 등 포함), UPS 등을 활용

## DBMS의 저장구조 (DBMS stoage architecture)

<img src="C:\Users\gusal\mini\routerbase\src\images\DBMS.png" alt="DBMS architecture" style="height:300px; width: 600px;"/>

## 데이터베이스 저장연산

1. 디스크와 메인 메모리 사이의 블록 이동
   * Input(Bi)
     * 데이터 Bi가 포함되어 있는 디스크 블록을 메인메모리로 이동
     * 요청에 의해(On demand) -> 수동적이다.
   * Output(Bj)
     * 데이터 Bj가 포함되어 있는 버퍼 블록을 디스크 블록에 이동시켜 기록
     * 버퍼 관리자에 의해 (by Buffer Manager)

2. 프로그램과 데이터베이스 사이의 데이터 이동
   * X: 데이터 아이템 이름
   * x: 프로그램 변수(local variable)

   * Read(X): 데이터 아이템 X를 읽어 지역 변수 x에 지정
      * 어떤 트랜젝션이 데이터 아이템 X에 처음 접근했을 때 수행
      * 내부적으로 Input(Bx)가 실행됨

    1. 데이터 아이템 X가 버퍼 블록에 없으면 X가 포함된 디스크 블록 Bx에 대해 Input(Bx)를 실행
    2. 버퍼 블록에 있는 데이터 아이템 X의 값을 변수 x에 지정

3. 버퍼 관리자의 Output(Bx) 수행 조건
    * 버퍼 관리자가 메모리 공간을 필요로 할 경우,
      * x의 버퍼 블록(Dirty block)을 강제 출력하고 다른 프로세스에게 할당
   * 데이터 베이스 시스템이 변경된 데이터 아이템 X값을 디스크에 반영하도록 요구할 경우
     * ex)  Mysql의 Flush 명령 등
   * 또는 기타 시스템의 조건이 충족되었을 경우.

### Read(X) -> 즉시 Input(bx) 실행

### Write(X) -> 즉시 Output(Bx) 실행되지 않음
* Output(Bx)가 실행되기 전에 시스템 붕괴 -> 변경된 X값 상실!!

---------------

## 트랜잭션

***일련의 연산 집합이며, DB 시스템에서 하나의 논리적 기능을 수행하기 위한 작업의 단위***

## 트랜잭션과 데이터베이스 상태와의 관계 

* T: Si -> Sj, Si, Sj (= S
* S: 데이터베이스의 일관된 상태 집합

## 트랜잭션의 특징(ACID)

* 원자성(Atomicity)
  *  더 이상 나누어 질 수 없는 작업 단위(All or Nothing)

* 일관성(Consistency)
    * 트랜잭션 실행 전과 후에도 항상 일관성을 유지해야 함.

* 격리성(Isolation)
  * 트랜잭션 실행 중 연산의 중간 결과를 다른 트랙잰션이 접근할 수 없음.

* 영속석(Durability)
  * 트랜잭션이 일단 성공적으로 샐행되면 그 결과는 영속적
  